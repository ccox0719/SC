<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Space Fleet Battle — 2P (Build+Replace, Cooldown Shields)</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#111826; --panel2:#172134; --ink:#e7eefc; --muted:#a9b4c8;
    --line:#243247;
    --p1:#6fb6ff; --p1-soft:#18324f; --p1-mid:#204469;
    --p2:#ff7b83; --p2-soft:#3a1c23; --p2-mid:#582c36;
    --good:#6ee7a8; --bad:#ff7189; --warn:#ffd36e; --accent:#7cc7ff;
    --hl:#8b5cf6; --shield:#93c5fd;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif}
  .app{display:grid;grid-template-columns:360px 1fr;gap:12px;max-width:1280px;margin:14px auto;padding:0 10px}
  .col{background:var(--panel);border:1px solid var(--line);border-radius:12px;overflow:hidden}
  header{padding:12px 14px;background:linear-gradient(180deg,var(--panel2),transparent);display:flex;justify-content:space-between;align-items:center}
  header h1{font-size:18px;margin:0}
  .turnpill{font-size:12px;border:1px solid var(--line);padding:4px 8px;border-radius:999px}
  .p1{color:var(--p1)} .p2{color:var(--p2)}
  .section{padding:12px;border-top:1px solid var(--line)}
  .stack{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{border:1px solid var(--line);background:#0f1827;color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn.primary{border-color:#38bdf8;background:#0b253d}
  .btn.warn{border-color:#f59e0b;background:#231a08}
  .btn.danger{border-color:#ef4444;background:#2a0f12}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .help{font-size:12px;color:var(--muted)}
  .board{display:grid;grid-template-columns:1fr;gap:12px}
  .side{border:1px dashed var(--line);border-radius:10px;padding:10px}
  .ships{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px;margin-top:8px}
  .ship{background:var(--panel2);border:1px solid #233044;border-radius:12px;padding:10px;position:relative;transition:transform .08s ease, box-shadow .08s ease}
  .ship.dead{opacity:.45;filter:grayscale(1)}
  .ship.hl{outline:2px solid var(--hl); box-shadow:0 0 0 4px #8b5cf633;}
  .flag{position:absolute;right:8px;top:8px;background:#ffd36e20;border:1px solid var(--warn);color:var(--warn);font-size:11px;border-radius:6px;padding:2px 6px}
  .reflect{position:absolute;left:8px;top:8px;background:#7affff22;border:1px solid #7affff;color:#9ff; font-size:11px;border-radius:6px;padding:2px 6px}
  .jokered{position:absolute;left:8px;bottom:8px;background:#ff7b831e;border:1px solid var(--bad);color:var(--bad);font-size:11px;border-radius:6px;padding:2px 6px}
  .shiphead{display:flex;align-items:center;gap:8px;margin-bottom:6px}
  .ship h3{margin:0;font-size:15px}
  .role{font-size:11px;border:1px solid #2b3a50;border-radius:999px;padding:2px 7px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:70px 1fr 60px;gap:8px;align-items:center}
  .engine{display:flex;align-items:center;justify-content:center;background:#061221;border:1px solid #1f2a3f;border-radius:10px;height:48px; font-weight:700; font-size:13px}
  .engine .icon{margin-right:4px;color:#93e5ff}
  .hull,.shieldBox{display:flex;gap:6px;align-items:center;flex-direction:column}
  .badge{display:inline-flex;gap:6px;align-items:center;border:1px solid #2b3a50;border-radius:999px;padding:2px 8px;font-size:13px}
  .shieldArc{width:100%;height:24px;background:linear-gradient(90deg,#93c5fd33,#93c5fd77,#93c5fd33);
             border:1px solid #93c5fd; border-radius:999px;display:flex;align-items:center;justify-content:center;
             color:#e8f2ff; font-weight:700; letter-spacing:.3px; box-shadow:0 0 16px #93c5fd44 inset;
             font-size:11px}
  .shieldArc.inactive{opacity:.55; filter:grayscale(.3)}
  .shieldArc.ping{animation:ping 380ms ease-out}
  @keyframes ping{ 0%{box-shadow:0 0 0 0 rgba(147,197,253,.9)} 100%{box-shadow:0 0 20px 6px rgba(147,197,253,0)} }
  .weps{margin-top:6px;font-size:13px}
  .dmg{position:absolute;right:8px;bottom:8px;display:flex;align-items:center;gap:6px;font-weight:700}
  .missile{width:18px;height:18px;border-radius:3px;background:linear-gradient(90deg,#bbb,#eee);border:1px solid #999;transform:skewX(-12deg)}
  .hand{display:flex;gap:6px;flex-wrap:wrap;border:1px dashed var(--line);padding:8px;border-radius:10px}
  .hand.p1{background:linear-gradient(180deg, var(--p1-soft), transparent)} 
  .hand.p2{background:linear-gradient(180deg, var(--p2-soft), transparent)}
  .card{border:1px solid #334155;background:#0f172a;border-radius:8px;padding:6px 7px;min-width:42px;text-align:center;cursor:pointer;user-select:none}
  .card.s{border-color:#374151} .card.c{border-color:#2dd4bf}
  .card.h{border-color:#fca5a5} .card.d{border-color:#93c5fd}
  .card.sel{outline:2px solid var(--accent)}
  .card.disabled{opacity:.4;cursor:not-allowed}
  .log{height:240px;overflow:auto;background:#0b1220;border-top:1px solid var(--line);padding:8px 10px;font-size:13px}
  .good{color:var(--good)} .bad{color:var(--bad)} .muted{color:var(--muted)}
  .controls-p1{box-shadow:inset 0 0 0 2px var(--p1-mid)}
  .controls-p2{box-shadow:inset 0 0 0 2px var(--p2-mid)}
  .turnbar{height:4px;background:linear-gradient(90deg, var(--p1) 0 50%, var(--p2) 50% 100%)}
  .onceNote{font-size:11px;color:var(--muted);margin-left:auto}
  .used{opacity:.7}
  .sep{height:8px}
  .select{border:1px solid var(--line);background:#0f1827;color:var(--ink);padding:6px 8px;border-radius:8px}
</style>
</head>
<body>
<div class="app">
  <div class="col" id="controlsCol">
    <header>
      <h1>Controls</h1>
      <div class="turnpill" id="turnPill">Turn: <span class="p1">Player 1</span></div>
    </header>
    <div class="section">
      <div class="stack">
        <button class="btn primary" id="btnBuild">Build</button>
        <button class="btn" id="btnAttack">Attack</button>
        <button class="btn" id="btnCrown">Play Ace (Crown)</button>
        <button class="btn" id="btnCancel">Cancel</button>
        <button class="btn warn" id="btnUndo">Undo</button>
        <button class="btn danger" id="btnNew">New Game</button>
        <button class="btn" id="btnEndTurn">End Turn</button>
        <span class="onceNote" id="onceNote">One action per turn</span>
      </div>
      <div class="sep"></div>
      <div class="stack">
        <label>AI (P2):</label>
        <select id="aiLevel" class="select">
          <option>Off</option>
          <option selected>Normal</option>
          <option>Easy</option>
          <option>Hard</option>
        </select>
      </div>
      <p class="help" id="actionHint">Select an action.</p>
    </div>
    <div class="section">
      <div class="row">
        <div><strong>Deck:</strong> <span id="deckCount"></span></div>
        <div><strong>Your hand:</strong> <span id="handCount"></span></div>
      </div>
    </div>
    <div class="section">
      <strong>Selected:</strong>
      <div id="selectedInfo" class="help">—</div>
    </div>
    <div class="turnbar" id="turnbar"></div>
  </div>

  <div class="col">
    <header><h1>Battlefield</h1><div><strong>Player Colors:</strong> <span class="p1">P1</span> / <span class="p2">P2</span></div></header>
    <div class="section board" id="board"></div>
    <div class="section">
      <strong>Hand</strong>
      <div id="hand" class="hand"></div>
    </div>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
/* ================= Utilities ================= */
const SUITS = ["C","H","D","S"];
const RANKS = [1,2,3,4,5,6,7,8,9,10,11,12,13]; // A=1
const deep = (o)=>JSON.parse(JSON.stringify(o));
const sum = arr => arr.reduce((a,b)=>a+b,0);
const lbl = (c)=> c.suit==="JOKER" ? "Joker" : ({1:"A",11:"J",12:"Q",13:"K"}[c.rank]||c.rank)+({C:"♣",H:"♥",D:"♦",S:"♠"}[c.suit]);

function makeDeck(){
  const deck = [];
  for(const s of SUITS){ for(const r of RANKS){ deck.push({suit:s, rank:r}); } }
  deck.push({suit:"JOKER",rank:0}); deck.push({suit:"JOKER",rank:0});
  for(let i=deck.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
  return deck;
}

/* ================= Game State ================= */
const state = {
  deck: [],
  players: [
    { id:0, name:"Player 1", color:"p1", hand:[], ships:[], drewTwo:false },
    { id:1, name:"Player 2", color:"p2", hand:[], ships:[], drewTwo:false },
  ],
  turn: 0,
  log: [],
  phase: "idle",
  pending: null,
  history: [],
  turnActionUsed: false
};

function snapshot(){ state.history.push(deep({deck:state.deck, players:state.players, turn:state.turn, phase:state.phase, pending:state.pending, log:state.log, turnActionUsed:state.turnActionUsed})); if(state.history.length>80) state.history.shift(); }
function undo(){ const snap = state.history.pop(); if(!snap) return; Object.assign(state, deep(snap)); render(); }

/* ================= Rules Helpers ================= */
function guaranteeAce(hand, deck){
  if(!hand.some(c=>c.rank===1)){
    const idx = deck.findIndex(c=>c.rank===1 && c.suit!=="JOKER");
    if(idx>=0){ hand.push(deck.splice(idx,1)[0]); }
  }
}
function roleOf(ship){
  const E=ship.engine, H=ship.hull;
  if(ship.weapons.length===0 || E===H) return "Support";
  if(E>H) return "Speed";
  return "Tank";
}
function usableWeapons(ship){
  const w = ship.weapons.filter(v=>v<=ship.engine);
  // if a weapon is locked this turn, we suppress strongest
  if(ship.weaponLockTurns>0 && w.length>0){
    const mx = Math.max(...w); const i = w.indexOf(mx); w.splice(i,1);
  }
  return w;
}
function shipDamage(ship){
  if(!ship.alive) return 0;
  const w = usableWeapons(ship);
  if(w.length===0) return roleOf(ship)==="Speed" ? 2 : 0;
  const base = Math.max(...w);
  const stack = w.length-1;
  let dmg = base + stack;
  if(roleOf(ship)==="Speed") dmg += 2;
  return Math.max(0,dmg);
}
function applyDamage(target, amount, {bypassShields=false}={}){
  let dealt = 0;
  // Active shields absorb up to their rating, then flip inactive (1-turn cooldown for the owner)
  if(!bypassShields && target.shieldValue>0 && target.shieldActive){
    const abs = Math.min(amount, target.shieldValue);
    amount -= abs; dealt += abs;
    pingShield(target.id);
    target.shieldActive = false;
    target.shieldCooldown = 1; // reactivates at start of owner's next turn
  }
  if(amount>0){
    target.hull -= amount; dealt += amount;
    if(target.hull<=0){ target.hull=0; target.alive=false; }
  }
  return dealt;
}
function totalHP(p){ // for deck-out comparison: Hull + (active shields count as full value)
  return sum(p.ships.filter(s=>s.alive).map(s=>s.hull + (s.shieldActive ? s.shieldValue : 0)));
}
function flagshipDestroyed(p){ return p.ships.some(s=>s.flagship) && !p.ships.some(s=>s.flagship && s.alive); }
function weakestEnemyShip(pid){
  const opp = state.players[1-pid];
  const alive = opp.ships.filter(s=>s.alive);
  alive.sort((a,b)=>((a.hull + (a.shieldActive?a.shieldValue:0)) - (b.hull + (b.shieldActive?b.shieldValue:0))) || a.engine-b.engine);
  return alive[0] || null;
}
function pingShield(shipId){
  const el = document.querySelector(`[data-sid="${shipId}"] .shieldArc`);
  if(el){ el.classList.remove('ping'); void el.offsetWidth; el.classList.add('ping'); }
}

/* ================= Init ================= */
function initGame(){
  state.deck = makeDeck();
  // starters (NOTE: shields now have value + active/cooldown)
  state.players[0].ships = [
    {id:"p1a", name:"P1 Ship A", engine:3, hull:2, shieldValue:2, shieldActive:true, shieldCooldown:0, weapons:[], weaponLockTurns:0, alive:true, flagship:false, reflect:false},
    {id:"p1b", name:"P1 Ship B", engine:4, hull:5, shieldValue:0, shieldActive:false, shieldCooldown:0, weapons:[], weaponLockTurns:0, alive:true, flagship:false, reflect:false}
  ];
  state.players[1].ships = [
    {id:"p2a", name:"P2 Ship A", engine:2, hull:3, shieldValue:3, shieldActive:true, shieldCooldown:0, weapons:[], weaponLockTurns:0, alive:true, flagship:false, reflect:false},
    {id:"p2b", name:"P2 Ship B", engine:5, hull:4, shieldValue:0, shieldActive:false, shieldCooldown:0, weapons:[], weaponLockTurns:0, alive:true, flagship:false, reflect:false}
  ];
  // hands P1:7, P2:6
  state.players[0].hand = state.deck.splice(-7); guaranteeAce(state.players[0].hand, state.deck);
  state.players[1].hand = state.deck.splice(-6); guaranteeAce(state.players[1].hand, state.deck);

  state.turn = 0;
  state.players[0].drewTwo = true; // only P2 uses the flag
  state.players[1].drewTwo = false;

  state.log = [];
  state.phase = "idle";
  state.pending = null;
  state.history = [];
  state.turnActionUsed = false;
  log(`New game. Player 1 begins. Player 2 will draw 2 on their first turn.`);
  startOfTurnDraw(state.players[0]); // P1 draws 1 at start
  render();
}

/* ================= Turn / Flow ================= */
function startOfTurnDraw(p){
  let n = 1;
  if(p.id===1 && !p.drewTwo){ n=2; p.drewTwo=true; }
  draw(p, n);
  // Reactivate shields & clear weapon locks for this player
  for(const s of p.ships){
    if(s.shieldCooldown>0){ s.shieldCooldown -= 1; if(s.shieldCooldown===0){ s.shieldActive = s.shieldValue>0; } }
    if(s.weaponLockTurns>0){ s.weaponLockTurns -= 1; }
  }
}
function draw(p, n){
  const take = state.deck.splice(-n);
  p.hand.push(...take);
  if(take.length>0) log(`${p.name} draws ${take.length} card${take.length>1?"s":""}.`);
}
function endTurn(){
  snapshot();
  // deck-out check
  if(state.deck.length===0){
    const p0=state.players[0], p1=state.players[1];
    const t0=totalHP(p0), t1=totalHP(p1);
    if(t0!==t1){
      const w = t0>t1 ? p0.name : p1.name;
      log(`Deck out → ${w} wins by totals (${t0} vs ${t1}).`,"good");
      freeze(); return;
    }else{
      log(`Deck out: equal totals (${t0}). Continue until a Flagship falls.`,"muted");
    }
  }
  state.turn = 1-state.turn;
  state.phase = "idle"; state.pending=null;
  state.turnActionUsed = false; // reset action budget
  const p = state.players[state.turn];
  startOfTurnDraw(p);
  checkWin();
  render();
  maybeRunAI();
}
function freeze(){ document.querySelectorAll("button").forEach(b=>b.disabled=true); }
function checkWin(){
  const p0=state.players[0], p1=state.players[1];
  if(flagshipDestroyed(p0)){ log("Player 2 wins (Player 1 Flagship destroyed).","good"); freeze(); }
  if(flagshipDestroyed(p1)){ log("Player 1 wins (Player 2 Flagship destroyed).","good"); freeze(); }
}

/* ================= Logging ================= */
function log(msg, cls=""){ state.log.unshift({msg,cls,t:Date.now()}); renderLog(); }

/* ================= One-Action Gate & Cancel ================= */
function actionGate(){ 
  if(state.turnActionUsed){ 
    setHint("You’ve already used your action this turn. End Turn to proceed."); 
    return true; 
  }
  return false;
}
function markActionUsed(){ state.turnActionUsed = true; }
function cancelFlow(){
  state.phase="idle"; state.pending=null; setHint("Action cancelled."); render();
}

/* ================= Action Logic ================= */
function beginBuild(){ if(actionGate()) return; state.phase="build_select_card"; state.pending={type:"build", combo:null}; setHint("Build: select a card (♣/♥/♦/♠). Tip: select a ♣ then a ♥ to replace a destroyed ship."); render(); }
function beginAttack(){ if(actionGate()) return; state.phase="attack_select_attacker"; state.pending={type:"attack"}; setHint("Attack: select your attacking ship (must have weapons)."); render(); }
function beginCrown(){
  if(actionGate()) return;
  const p = me();
  const idx = p.hand.findIndex(c=>c.rank===1 && c.suit!=="JOKER");
  if(idx<0){ setHint("You have no Ace."); return; }
  state.phase="crown_select_ship"; state.pending={type:"crown", cardIdx:idx};
  setHint("Select a ship to crown (Engine becomes at least 5)."); render();
}
function applyCrown(shipId){
  snapshot();
  const p = me();
  const i = state.pending.cardIdx;
  const ship = p.ships.find(s=>s.id===shipId && s.alive);
  if(!ship) return;
  ship.flagship=true; if(ship.engine<5) ship.engine=5;
  p.hand.splice(i,1);
  log(`${p.name} crowns ${ship.name}. Engine ≥ 5.`,"good");
  state.phase="idle"; state.pending=null; markActionUsed(); render(); checkWin(); maybeRunAI();
}
function me(){ return state.players[state.turn]; }
function opp(){ return state.players[1-state.turn]; }

/* ===== Build selection ===== */
function handleBuildSelectCard(cardIdx){
  const p = me();
  const card = p.hand[cardIdx];
  if(!card) return;

  // specials & joker are one action
  if(card.suit==="JOKER" || (card.suit==="S" && [11,12,13].includes(card.rank))){
    state.phase="special_target"; state.pending={type:"special", cardIdx, card};
    if(card.suit==="JOKER") setHint("Joker: select an enemy ship (strongest weapon becomes inactive for 1 turn).");
    else if(card.rank===11) setHint("J♠: select any enemy ship (3 Hull, bypass Shields).");
    else if(card.rank===12) setHint("Q♠: select your strongest ship for reflect (≤5 on next attack).");
    else if(card.rank===13) setHint("K♠: select any enemy ship (7 Hull, bypass Shields).");
    render();
    return;
  }

  // handle potential launch combo: store first if ♣ or ♥ selected for combo
  if(state.pending && state.pending.type==="build" && !state.pending.combo){
    if(card.suit==="C" || card.suit==="H"){
      state.pending.combo = { firstIdx: cardIdx, first: card };
      setHint(`Selected ${lbl(card)}. Select a ${card.suit==="C"?"♥":"♣"} to launch a replacement ship, or click a ship to apply ${lbl(card)} as a normal upgrade.`);
      state.phase="build_select_card2";
      render(); return;
    }
  }

  // if we are in combo phase and picked the complementary suit, attempt launch
  if(state.phase==="build_select_card2" && state.pending?.combo){
    const first = state.pending.combo.first;
    const second = card;
    const both = new Set([first.suit, second.suit]);
    if(both.has("C") && both.has("H")){
      // Launch/replace ship requires a destroyed slot (max 2 alive ships)
      const pShips = p.ships;
      const dead = pShips.find(s=>!s.alive);
      if(!dead){
        // if all alive and we have less than 2 ships (shouldn’t happen in this build), allow add; otherwise need a destroyed
        setHint("No destroyed ship to replace. You can only launch when you have a destroyed ship.");
        return;
      }
      snapshot();
      // consume both cards
      const i1 = state.pending.combo.firstIdx;
      const i2 = cardIdx > i1 ? cardIdx-1 : cardIdx; // adjust second index if needed
      p.hand.splice(Math.max(i1,i2),1); p.hand.splice(Math.min(i1,i2),1);
      // replace stats
      const club = first.suit==="C"? first : second;
      const heart= first.suit==="H"? first : second;
      dead.engine = club.rank;
      dead.hull   = heart.rank;
      dead.weapons = [];
      dead.weaponLockTurns = 0;
      dead.shieldValue = 0;
      dead.shieldActive = false;
      dead.shieldCooldown = 0;
      dead.alive = true;
      dead.flagship = false;
      dead.reflect = false;
      log(`${p.name} launches a replacement ship on ${dead.name}: Engine ${club.rank} / Hull ${heart.rank}.`,"good");
      state.phase="idle"; state.pending=null; markActionUsed(); render(); maybeRunAI();
      return;
    }
  }

  // Otherwise it’s a normal one-card build
  state.phase="build_select_ship"; state.pending={type:"build", cardIdx, card};
  setHint(`Build: select a ship for ${lbl(card)}.`);
  render();
}

function canApplyCardToShip(card, ship, ownerId){
  if(!ship.alive) return false;
  if(state.phase==="build_select_ship"){
    if(me().id!==ownerId) return false;
    if(card.suit==="C") return true;
    if(card.suit==="H") return true;
    if(card.suit==="D") return true;
    if(card.suit==="S" && card.rank>=2 && card.rank<=10) return card.rank <= ship.engine;
    return false;
  }
  if(state.phase==="special_target"){
    const mine = ownerId===me().id;
    if(card.suit==="JOKER"){ return !mine && ship.alive; } // can target any enemy ship; lock strongest weapon 1 turn
    if(card.suit==="S" && card.rank===11){ return !mine && ship.alive; }
    if(card.suit==="S" && card.rank===12){ return mine && ship.alive; }
    if(card.suit==="S" && card.rank===13){ return !mine && ship.alive; }
  }
  return false;
}

function applyBuildToShip(shipId){
  snapshot();
  const p = me(); const pend = state.pending; if(!pend) return;
  const card = p.hand[pend.cardIdx]; if(!card) return;
  const ship = p.ships.find(s=>s.id===shipId); if(!ship) return;

  if(card.suit==="C"){ ship.engine=Math.max(ship.engine, card.rank); p.hand.splice(pend.cardIdx,1); log(`${p.name} upgrades Engine on ${ship.name} → ${ship.engine}.`); }
  else if(card.suit==="H"){ ship.hull+=card.rank; p.hand.splice(pend.cardIdx,1); log(`${p.name} adds ${card.rank} Hull to ${ship.name}.`); }
  else if(card.suit==="D"){ ship.shieldValue=Math.max(ship.shieldValue, card.rank); ship.shieldActive=true; ship.shieldCooldown=0; p.hand.splice(pend.cardIdx,1); log(`${p.name} sets Shield ${ship.shieldValue} (Active) on ${ship.name}.`); }
  else if(card.suit==="S" && card.rank>=2 && card.rank<=10){
    if(card.rank>ship.engine){ setHint(`Engine ${ship.engine} too low for weapon ${card.rank}.`); state.history.pop(); return; }
    ship.weapons.push(card.rank); p.hand.splice(pend.cardIdx,1);
    log(`${p.name} installs weapon ${card.rank}♠ on ${ship.name}.`);
  }else{ state.history.pop(); return; }

  state.phase="idle"; state.pending=null; markActionUsed(); render(); maybeRunAI();
}

/* ===== Specials ===== */
function applySpecialOn(targetId){
  snapshot();
  const p = me(), o = opp(); const pend = state.pending; if(!pend) return;
  const card = p.hand[pend.cardIdx]; if(!card) return;

  if(card.suit==="JOKER"){
    const tgt = o.ships.find(s=>s.id===targetId && s.alive);
    if(!tgt){ state.history.pop(); return; }
    tgt.weaponLockTurns = 1; // strongest weapon inactive for 1 turn
    p.hand.splice(pend.cardIdx,1);
    log(`${p.name} plays Joker on ${o.name}'s ${tgt.name}: strongest weapon inactive for 1 turn.`,"warn");
  }else if(card.suit==="S" && card.rank===11){
    const tgt = o.ships.find(s=>s.id===targetId && s.alive);
    if(!tgt){ state.history.pop(); return; }
    tgt.hull -= 3; if(tgt.hull<=0){tgt.hull=0; tgt.alive=false;}
    p.hand.splice(pend.cardIdx,1);
    log(`${p.name} plays J♠: 3 Hull to ${tgt.name} (bypass).`,"bad");
  }else if(card.suit==="S" && card.rank===12){
    const my = p.ships.find(s=>s.id===targetId && s.alive);
    if(!my){ state.history.pop(); return; }
    my.reflect = true; p.hand.splice(pend.cardIdx,1);
    log(`${p.name} plays Q♠: ${my.name} will reflect up to 5 on its next attack.`,"good");
  }else if(card.suit==="S" && card.rank===13){
    const tgt = o.ships.find(s=>s.id===targetId && s.alive);
    if(!tgt){ state.history.pop(); return; }
    tgt.hull -= 7; if(tgt.hull<=0){tgt.hull=0; tgt.alive=false;}
    p.hand.splice(pend.cardIdx,1);
    log(`${p.name} plays K♠: 7 Hull to ${tgt.name} (bypass).`,"bad");
  }else{ state.history.pop(); return; }

  state.phase="idle"; state.pending=null; markActionUsed(); render(); checkWin(); maybeRunAI();
}

/* ===== Attack ===== */
function selectAttacker(shipId){
  if(actionGate()) return;
  const p = me();
  const sh = p.ships.find(s=>s.id===shipId && s.alive);
  if(!sh) return;
  const dmg = shipDamage(sh);
  if(dmg<=0){ setHint("That ship has no usable weapons."); return; }
  state.phase="attack_select_target"; state.pending={type:"attack", attackerId: shipId, dmg};
  setHint(`Attack: select an enemy target (damage = ${dmg}).`); render();
}
function performAttackOn(targetId){
  snapshot();
  const p=me(), o=opp(); const pend=state.pending; if(!pend) return;
  const atk = p.ships.find(s=>s.id===pend.attackerId && s.alive);
  const tgt = o.ships.find(s=>s.id===targetId && s.alive);
  if(!atk || !tgt){ state.history.pop(); return; }
  const dmg = shipDamage(atk);
  applyDamage(tgt, dmg, {bypassShields:false});
  log(`${p.name} attacks with ${atk.name} for ${dmg} → ${o.name}'s ${tgt.name} ${tgt.alive?`(H${tgt.hull}${tgt.shieldActive?` Sh${tgt.shieldValue}`:" Sh–"})`:"destroyed!"}`, tgt.alive?"":"bad");

  if(atk.reflect){
    const ref = Math.min(5, dmg);
    applyDamage(atk, ref, {bypassShields:false});
    log(`Reflect triggers on ${atk.name}: takes ${ref}.`,"muted");
    atk.reflect=false;
  }

  state.phase="idle"; state.pending=null; markActionUsed(); render(); checkWin(); maybeRunAI();
}

/* ================= AI (P2) with difficulty ================= */
function aiLevel(){
  const v = document.getElementById("aiLevel").value;
  return v; // "Off" | "Easy" | "Normal" | "Hard"
}
function aiOn(){ return aiLevel()!=="Off"; }
function maybeRunAI(){
  if(!aiOn()) return;
  if(state.turn!==1) return;
  setTimeout(aiTakeTurn, 220);
}
function pickWeakestTarget(pid){
  return weakestEnemyShip(pid);
}
function aiTakeTurn(){
  if(document.getElementById("btnEndTurn").disabled) return;
  if(state.turn!==1) return;
  const level = aiLevel(); if(level==="Off") return;

  // If action spent (shouldn't happen at start), end turn
  if(state.turnActionUsed){ endTurn(); return; }

  const p = me(), o = opp();

  // Heuristic weights by difficulty
  const prefer = {
    Easy:   ["attack","hull","shield","spade","club","special","crown","joker","engineToFit"],
    Normal: ["crown","lethalK","lethalJ","spade","engineToFit","attack","hull","shield","joker"],
    Hard:   ["crown","lethalK","lethalJ","joker","spade","engineToFit","attack","hull","shield"]
  }[level];

  function tryCrown(){
    const hasFlag = p.ships.some(s=>s.flagship);
    const aceIdx = p.hand.findIndex(c=>c.rank===1 && c.suit!=="JOKER");
    if(!hasFlag && aceIdx>=0){
      state.pending={type:"crown",cardIdx:aceIdx};
      const best = p.ships.filter(s=>s.alive).sort((a,b)=> (b.engine+b.hull+(b.shieldActive?b.shieldValue:0)) - (a.engine+a.hull+(a.shieldActive?a.shieldValue:0)))[0];
      applyCrown(best.id); return true;
    }
    return false;
  }
  function tryLethalK(){
    const idx = p.hand.findIndex(c=>c.suit==="S" && c.rank===13);
    const t = pickWeakestTarget(p.id);
    if(idx>=0 && t && t.hull<=7){ state.pending={type:"special",cardIdx:idx,card:p.hand[idx]}; applySpecialOn(t.id); return true; }
    return false;
  }
  function tryLethalJ(){
    const idx = p.hand.findIndex(c=>c.suit==="S" && c.rank===11);
    const t = pickWeakestTarget(p.id);
    if(idx>=0 && t && t.hull<=3){ state.pending={type:"special",cardIdx:idx,card:p.hand[idx]}; applySpecialOn(t.id); return true; }
    return false;
  }
  function tryJoker(){
    const idx = p.hand.findIndex(c=>c.suit==="JOKER");
    if(idx<0) return false;
    const tgt = opp().ships.filter(s=>s.alive && usableWeapons(s).length>0).sort((a,b)=> shipDamage(b)-shipDamage(a))[0];
    if(!tgt) return false;
    state.pending={type:"special",cardIdx:idx,card:p.hand[idx]}; applySpecialOn(tgt.id); return true;
  }
  function trySpade(){
    const sp = p.hand.filter(c=>c.suit==="S" && c.rank>=2 && c.rank<=10).sort((a,b)=>a.rank-b.rank)[0];
    if(!sp) return false;
    // fit on ship with lowest current damage but fitting engine
    const fit = p.ships.filter(s=>s.alive && sp.rank<=s.engine).sort((a,b)=> shipDamage(a)-shipDamage(b))[0];
    if(!fit) return false;
    state.phase="build_select_ship"; state.pending={type:"build",cardIdx:p.hand.indexOf(sp),card:sp}; applyBuildToShip(fit.id); return true;
  }
  function tryEngineToFit(){
    const sp = p.hand.filter(c=>c.suit==="S" && c.rank>=2 && c.rank<=10).sort((a,b)=>a.rank-b.rank)[0];
    if(!sp) return false;
    const need = sp.rank;
    const club = p.hand.filter(c=>c.suit==="C").sort((a,b)=>b.rank-a.rank)[0];
    const tgt = p.ships.filter(s=>s.alive).sort((a,b)=>a.engine-b.engine)[0];
    if(club && tgt && tgt.engine<need){ state.phase="build_select_ship"; state.pending={type:"build",cardIdx:p.hand.indexOf(club),card:club}; applyBuildToShip(tgt.id); return true; }
    return false;
  }
  function tryHull(){
    const heart = p.hand.filter(c=>c.suit==="H").sort((a,b)=>a.rank-b.rank)[0];
    if(!heart) return false;
    const s = p.ships.filter(s=>s.alive).sort((a,b)=> (a.hull+(a.shieldActive?a.shieldValue:0)) - (b.hull+(b.shieldActive?b.shieldValue:0)) )[0];
    state.phase="build_select_ship"; state.pending={type:"build",cardIdx:p.hand.indexOf(heart),card:heart}; applyBuildToShip(s.id); return true;
  }
  function tryShield(){
    const diam = p.hand.filter(c=>c.suit==="D").sort((a,b)=>b.rank-a.rank)[0];
    if(!diam) return false;
    const s = p.ships.filter(s=>s.alive).sort((a,b)=> (a.shieldActive?1:0) - (b.shieldActive?1:0) || a.shieldValue-b.shieldValue )[0];
    state.phase="build_select_ship"; state.pending={type:"build",cardIdx:p.hand.indexOf(diam),card:diam}; applyBuildToShip(s.id); return true;
  }
  function tryAttack(){
    const atk = p.ships.filter(s=>s.alive && shipDamage(s)>0).sort((a,b)=> shipDamage(b)-shipDamage(a))[0];
    const tar = pickWeakestTarget(p.id);
    if(atk && tar){ state.phase="attack_select_target"; state.pending={type:"attack",attackerId:atk.id}; performAttackOn(tar.id); return true; }
    return false;
  }

  const plays = {
    crown: tryCrown, lethalK: tryLethalK, lethalJ: tryLethalJ, joker: tryJoker,
    spade: trySpade, engineToFit: tryEngineToFit, hull: tryHull, shield: tryShield, attack: tryAttack
  };

  for(const key of prefer){
    if(plays[key] && plays[key]()) return;
  }
  endTurn();
}

/* ================= Rendering ================= */
function setHint(t){ document.getElementById("actionHint").textContent=t; }
function setSelected(t){ document.getElementById("selectedInfo").textContent=t||"—"; }
function render(){
  // color-code controls & hand by turn
  const col = document.getElementById("controlsCol");
  col.classList.toggle("controls-p1", me().color==="p1");
  col.classList.toggle("controls-p2", me().color==="p2");
  document.getElementById("turnPill").innerHTML = `Turn: <span class="${me().color}">${me().name}</span>`;
  const handDiv = document.getElementById("hand");
  handDiv.classList.toggle("p1", me().color==="p1");
  handDiv.classList.toggle("p2", me().color==="p2");
  document.getElementById("deckCount").textContent = state.deck.length;
  document.getElementById("handCount").textContent = me().hand.length;

  // Battlefield
  const b = document.getElementById("board"); b.innerHTML="";
  state.players.forEach(p=>{
    const side = document.createElement("div"); side.className="side";
    side.innerHTML = `<div><strong class="${p.color}">${p.name}</strong></div>`;
    const grid = document.createElement("div"); grid.className="ships";

    const highlightMap = computeShipHighlights(p.id);

    p.ships.forEach(s=>{
      const d = document.createElement("div"); d.className="ship"+(s.alive?"":" dead"); d.dataset.sid = s.id;
      if(highlightMap[s.id]) d.classList.add("hl");

      const role = roleOf(s);
      const dmg = shipDamage(s);
      const wlist = usableWeapons(s).sort((a,b)=>b-a);
      const shieldText = s.shieldValue ? (s.shieldActive ? `♦ Shield ${s.shieldValue}` : `♦ Shield ${s.shieldValue} (inactive)`) : `<span class="muted">No Shield</span>`;
      const shieldClasses = `shieldArc ${s.shieldActive?"":"inactive"}`;

      d.innerHTML = `
        ${s.flagship?`<div class="flag">Flagship</div>`:""}
        ${s.reflect?`<div class="reflect">Reflect</div>`:""}
        ${s.weaponLockTurns>0?`<div class="jokered">Weapon Locked</div>`:""}
        <div class="shiphead"><h3>${s.name}</h3><span class="role">${role}</span></div>
        <div class="grid">
          <div class="hull">
            <span class="badge"><span class="icon">♥</span> ${s.hull}</span>
            <div class="${shieldClasses}">${shieldText}</div>
          </div>
          <div class="engine"><span class="icon">♣</span> ${s.engine}</div>
          <div class="weapons">
            <div class="badge"><span class="icon">♠</span> ${wlist.length? wlist.join(", ") : "—"}</div>
          </div>
        </div>
        <div class="dmg"><div class="missile"></div> ${dmg}</div>
      `;
      d.addEventListener("click", ()=>{
        const phase = state.phase;
        if(phase==="build_select_ship"){ applyBuildToShip(s.id); }
        else if(phase==="attack_select_attacker" && p.id===me().id){ selectAttacker(s.id); }
        else if(phase==="attack_select_target" && p.id===opp().id){ performAttackOn(s.id); }
        else if(phase==="crown_select_ship" && p.id===me().id){ applyCrown(s.id); }
        else if(phase==="special_target"){ applySpecialOn(s.id); }
        else setSelected(`Ship • ${s.name} — E:${s.engine} H:${s.hull} Sh:${s.shieldValue? (s.shieldActive? s.shieldValue+" (A)" : s.shieldValue+" (I)") : "—"} | Role:${role} | Dmg:${dmg}`);
      });

      grid.appendChild(d);
    });

    side.appendChild(grid); b.appendChild(side);
  });

  // Hand
  const hand = document.getElementById("hand"); hand.innerHTML="";
  const p = me();
  p.hand.forEach((c,idx)=>{
    const el=document.createElement("div"); el.className="card "+({C:"c",H:"h",D:"d",S:"s"}[c.suit]||"");
    el.textContent=lbl(c);
    if(state.phase==="build_select_ship" || state.phase==="special_target") el.classList.add("disabled");
    el.addEventListener("click", ()=>{
      if(state.phase==="build_select_card" || state.phase==="build_select_card2"){ handleBuildSelectCard(idx); }
      else { setSelected(`Card • ${lbl(c)}`); }
    });
    hand.appendChild(el);
  });

  // Buttons (disabled after action)
  const used = state.turnActionUsed;
  const inFlow = state.phase!=="idle";
  document.getElementById("btnBuild").disabled = used || inFlow;
  document.getElementById("btnAttack").disabled = used || inFlow;
  document.getElementById("btnCrown").disabled = used || inFlow;
  document.getElementById("btnCancel").disabled = !inFlow;
  if(used) document.getElementById("onceNote").classList.add("used"); else document.getElementById("onceNote").classList.remove("used");
}

function computeShipHighlights(ownerId){
  const map = {};
  const phase = state.phase, pend=state.pending;

  if((phase==="build_select_ship" || phase==="build_select_card2") && pend?.card){
    for(const s of state.players[ownerId].ships){
      if(canApplyCardToShip(pend.card, s, ownerId)) map[s.id]=true;
    }
  }
  if(phase==="attack_select_attacker" && ownerId===me().id){
    for(const s of state.players[ownerId].ships){ if(s.alive && shipDamage(s)>0) map[s.id]=true; }
  }
  if(phase==="attack_select_target" && ownerId===opp().id){
    for(const s of state.players[ownerId].ships){ if(s.alive) map[s.id]=true; }
  }
  if(phase==="crown_select_ship" && ownerId===me().id){
    for(const s of state.players[ownerId].ships){ if(s.alive) map[s.id]=true; }
  }
  if(phase==="special_target" && pend?.card){
    for(const s of state.players[ownerId].ships){
      if(canApplyCardToShip(pend.card, s, ownerId)) map[s.id]=true;
    }
  }
  return map;
}

function renderLog(){ document.getElementById("log").innerHTML = state.log.map(l=>`<div class="${l.cls||''}">${l.msg}</div>`).join(""); }

/* ================= Wiring ================= */
document.getElementById("btnBuild").addEventListener("click", ()=> beginBuild());
document.getElementById("btnAttack").addEventListener("click", ()=> beginAttack());
document.getElementById("btnCrown").addEventListener("click", ()=> beginCrown());
document.getElementById("btnCancel").addEventListener("click", ()=> cancelFlow());
document.getElementById("btnUndo").addEventListener("click", ()=> undo());
document.getElementById("btnNew").addEventListener("click", ()=> initGame());
document.getElementById("btnEndTurn").addEventListener("click", ()=> endTurn());

/* ================= Start ================= */
initGame();
</script>
</body>
</html>